from Crypto.Util.number import inverse, long_to_bytes
from sympy.ntheory.residue_ntheory import sqrt_mod

p = 13994412669234609338382070035828842075821156520953224193008056096335732745412338588897899329845770339866881417758766049189609577213796797792619484617235138628836591043
g = 2
public = 8962108921839628669925595280518189557675909556929524633705178282267484672964279384499328045114958041039945584910009602388983020666597829292440945909861677128315959796

flag_1 = 1504044924517843041691251671933347372553129292524043422228152158364037714863087923285464062156635541461702513891603602761723205435208183922308152635941537709699143516
flag_2 = 5705208632472445078365604525851780905142882780351003274522672255045782629740160678371042099342323998056470686783510970598737630060580461354336864487418751421591733500
flag_3 = 4671704318922182572285443424630632892600900026101973210309734286444545673353587119448511310282531685421433088520025792499553734457054486342720774084337896569964226103

a = ((flag_3 - flag_2) * inverse(flag_2 - flag_1, p)) % p
c = (flag_2 - a * flag_1) % p
f0 = (inverse(a, p) * (flag_1 - c)) % p
s_squared = (public * inverse(4, p)) % p
s_candidates = sqrt_mod(s_squared, p, all_roots=True)

for s in s_candidates:
    possible_flag = f0 ^ s
    try:
        flag = long_to_bytes(possible_flag)
        if b"CTF{" in flag:
            print(flag)
    except:
        pass
